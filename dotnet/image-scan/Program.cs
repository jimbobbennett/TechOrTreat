// More .NET IoT Samples here:
// * https://github.com/microsoft/Windows-iotcore-samples
// * https://github.com/dotnet/iot

using System;
using System.Device.Spi;
using System.Drawing;
using System.Net;
using Iot.Device.Ws28xx;

// This code sample uses C# 9's Top Level Statements feature.
// A Main method is generated by the compiler for us.
// Learn more: https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements

static int GetLedCount() {
    int count;
    if (!int.TryParse(Environment.GetEnvironmentVariable("LED_COUNT"), out count)) {
        // If we fail to parse the number of LED's or it is undefined set to 1 so we still attempt to light something.
        // If you're running this and 1 LED is always lighting up make sure LED_COUNT is set in your env.
        Console.WriteLine("⚠ LED_COUNT was not found or couldn't be parsed.");
        count = 1;
    }
    return count;
}

// Download an image from IMAGE_PATH and return the downloaded Bitmap
// Requires libgdiplus:
//   apt-get update && apt-get install -y libgdiplus
static Bitmap GetImage() {
    using (WebClient client = new WebClient()) {
        var imagePath = Environment.GetEnvironmentVariable("IMAGE_PATH");
        var stream = client.OpenRead(imagePath);
        if (stream != null) {
            var bitmap = new Bitmap(stream);
            stream.Flush();
            stream.Close();
            return bitmap;
        } else {
            return null;
        }
    }
}

// Limit a value to between a minimum and maximum value
// This can prevent out of bounds indexes on the strip
static int Clamp(int value, int min, int max) {
    if (value > max) {
        return max;
    } else if (value < min) {
        return min;
    } else {
        return value;
    }
}

static Color Lerp(Color left, Color right, float value) {
    var otherValue = (1 - value);
    var r = Clamp((int)(left.R * otherValue + right.R * value), 0, 255);
    var g = Clamp((int)(left.G * otherValue + right.G * value), 0, 255);
    var b = Clamp((int)(left.B * otherValue + right.B * value), 0, 255);
    var a = Clamp((int)(left.A * otherValue + right.A * value), 0, 255);
    return Color.FromArgb(a, r, g, b);
}

var ledCount = GetLedCount();
var referenceImage = GetImage();
Console.WriteLine($"Coloring {ledCount} LEDs...");

var connectionSettings = new SpiConnectionSettings(0, 0) {
    ClockFrequency = 2400000,
    Mode = SpiMode.Mode0,
    DataBitLength = 8,
    
};

// Create an SPI device based on the current operating system.
// For Raspbian this should be a UnixSpiDevice.
var spiDevice = SpiDevice.Create(connectionSettings);
// Ws2812b is the spec for the type of lights we are using.
// The device we create is how we communicate with our LED's
var device = new Ws2812b(spiDevice, ledCount);
var image = device.Image;

var y = 0;

while(true)
{
    y = (y + 1) % referenceImage.Height;
    // Clear the previous state.
    image.Clear();
    // Assign all pixels in the LED Strip to have the same color.
    for(int led = 0; led < ledCount; ++led) {
        var x = (led / (float)ledCount) * referenceImage.Width;
        var color = referenceImage.GetPixel((int)Math.Round(x),y);
        image.SetPixel(led, 0, color);
    }
    device.Update(); // Actually update the LED strip

    System.Threading.Thread.Sleep(50);
}